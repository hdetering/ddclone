{
    "contents" : "source(\"R/decay.R\")\nsource(\"R/helper.R\")\nsource(\"R/helper-math.R\")\nsource('R/env-setup.R')\n\nlibrary(plyr)\nlibrary(Matrix)\nlibrary(mcclust)\n\n\nappend.traj <- function(phi.traj, clust.traj, hyper.param.traj, expPath) {\n  write.table(phi.traj, file.path(expPath, 'phi-trace.csv'))\n  write.table(clust.traj, file.path(expPath, 'clust-trace.csv'))\n  write.table(hyper.param.traj, file.path(expPath, 'param-trace.tsv'), sep='\\t')\n}\n\n# ddcrp sampler\nddcrp.gibbs <- function(dat, dist.fn, decay.fn, lhood.fn, summary.fn = ncomp.summary,\n                        log.prior.thresh=-10, clust.traj=FALSE, phi.traj=FALSE,\n                        hyperParams, processor.fn=NULL, MCMCOptions=NULL,\n                        permuteCustomers = T, resampleHyperParams = T, expPath)\n{\n  ### set up summary statistics and trajectories\n  if (is.null(MCMCOptions)) {\n    MCMCOptions <- list(thinning=1, niter=100, burnIn=10)\n  }\n\n  niter <- MCMCOptions$niter\n  ndata <- dim(dat)[1]\n  msg.inc <- 10^(floor(log10(dim(dat)[1]))-1)\n  pb <- txtProgressBar(style=3)\n\n  if (clust.traj) {\n    clust.traj <- matrix(NA, nrow=niter, ncol=ndata)\n  }\n  if (phi.traj) {\n    phi.traj <- matrix(NA, nrow=niter, ncol=ndata)\n  }\n\n  hyperParamTraj <- matrix(NA, nrow=niter, ncol=3)\n  colnames(hyperParamTraj) <- c('a', 'alpha', 's')\n\n  score <- numeric(niter)\n  map.score <- 0\n\n  ### set up initial state, summaries, and cluster likelihoods\n  msg(\"setting up the initial state\")\n  st <- data.frame(idx=1:ndata, cluster=1:ndata, customer=1:ndata)\n  lhood <- daply(st, .(cluster), function(df) lhood.fn(dat[df$idx,], hyperParams$s))\n  summary <- summary.fn(dat, 0, st, lhood, hyperParams$alpha)\n\n  # precompute log.prior\n  ## log.prior.lst is indexed first by alpha, then by a\n  N <- nrow(Decay.CACHED$decays[[1]])\n  n_a <- length(Decay.CACHED$a)\n  n_alpha <- length(AlphaCACHED$alpha)\n  ldecay <- array(.1, dim=c(n_a, N, N))\n  l.prior.mat <- array(.1, dim=c(n_alpha, n_a, N, N))\n  l.alpha <- safelog(AlphaCACHED$alpha)\n  for (aIndex in 1:n_a) {\n    ldecay[aIndex, ,] <- safelog(Decay.CACHED$decays[[aIndex]])\n    for (alphaIndex in 1:n_alpha) {\n      diag(ldecay[aIndex, ,]) <- l.alpha[alphaIndex]\n      diag(Decay.CACHED$decays[[aIndex]]) <- AlphaCACHED$alpha[alphaIndex]\n      l.prior.mat[alphaIndex, aIndex, ,] <- ldecay[aIndex, ,] - array(safelog(rowSums(Decay.CACHED$decays[[aIndex]])), dim = c(N, N))\n    }\n  }\n  l.prior.mat[, , ,][which(l.prior.mat[, , ,] < log.prior.thresh)] <- NA\n\n  msg(\"Done setting up the initial state\")\n\n\n  ### run for niter iterations\n  for (iter in 1:niter) {\n    iter.score <- 0\n\n    ## set the customer order for this iteration\n    permuted <- seq(1, ndata)\n    if (permuteCustomers) {\n      permuted <- sample(permuted)\n    }\n\n    ## run the sitting sampler for each customer\n    tableRes <- ddcrp.resample.tables.assignments(permuted, st, lhood, lhood.fn, hyperParams, l.prior.mat, dat)\n    iter.score <- tableRes$iter.score\n    lhood <- tableRes$lhood\n    st <- tableRes$st\n\n    ### update the summary\n    iter.score <- iter.score + sum(lhood)\n    score[iter] <- iter.score\n    if ((score[iter] > map.score) || (iter==1)) {\n      map.score <- score[iter]\n      map.state <- st\n    }\n    summary <- rbind(summary, summary.fn(dat, iter, st, lhood, hyperParams$alpha))\n\n\n    ### sample table parameters\n    if (!is.null(dim(clust.traj))) clust.traj[iter,] <- st$cluster\n    if (!is.null(dim(phi.traj))) phi.traj[iter,] <- cached.sample.pyclone.cluster.parameters(st, hyperParams$s)$phi\n\n    ## update all hyperparameters\n    hyperParamTraj[iter, 'a'] <- hyperParams$a\n    hyperParamTraj[iter, 'alpha'] <- hyperParams$alpha\n    hyperParamTraj[iter, 's'] <- hyperParams$s\n\n    if (iter %% 20 == 0)\n      append.traj(phi.traj, clust.traj, hyperParamTraj, expPath)\n\n    if (resampleHyperParams) {\n      shuffle <- c(1,2,3) # 1. a.decay.f, 2. alpha.dirichlet , 3. s.betaBinom\n      shuffleList <- sample(shuffle)\n      if (length(shuffle) == 1) shuffleList <- shuffle\n\n      for (i in shuffleList) {\n        if (i == 1) {\n          hyperParams$a <- cached.resmple.decay.fn.param(state=map.state, alpha=hyperParams$alpha)\n        } else if (i == 2) {\n          hyperParams$alpha <- cached.resample.alpha(state=map.state, a=hyperParams$a)\n        } else if (i == 3) {\n          hyperParams$s <- resample.neal.precision(state=map.state, cluster.fn = lhood.fn, hyperParams$s)\n        }\n      }\n    }\n\n    setTxtProgressBar(pb, iter/niter)\n  }\n\n  close(pb)\n  ### return everything\n  list(summary=summary, clust.traj=clust.traj, phi.traj=phi.traj, score=score,\n       map.score = map.score, map.state = map.state, hyperParams = hyperParams, hyperParamTraj=hyperParamTraj)\n}\n\n\nddcrp.resample.tables.assignments <- function(customerOrder, st, lhood, lhood.fn, hyperParams, l.prior.mat, dat) {\n  iter.score <- 0\n  for (i in customerOrder) { # note: index i = 1 is correct at the outset\n    ### \"remove\" the i-th data point from the state\n    ### to do this, set its cluster to i, and set its connected data to i\n    old.cluster <- st$cluster[i]\n    old.customer <- st$customer[i]\n    conn.i <- connections(i, st$customer) # all who are connected to i from back and i, NOT THOSE that i is connected to\n    st$cluster[conn.i] <- i   # why? splitting the table for customers that remain connected to this customer\n    # why set to i? what if there is other cluster called i?\n    st$customer[i] <- i # self loop\n\n    if (old.customer == i) {\n      lhood[char(old.cluster)] <- 0\n    } else if (old.customer != i) {\n      old.idx <- st$idx[st$cluster==old.cluster]\n      # if old connections are still connected to i, then old.idx will be null and there'll be no need to update likelihoods\n      if (!is.null(old.idx) & length(old.idx) != 0) {\n        lhood[char(old.cluster)] <- lhood.fn(dat[old.idx,], hyperParams$s)\n      }\n    }\n\n    ### get log prior\n    aIndex <- which.min(abs(hyperParams$a - Decay.CACHED$a))\n    alphaIndex <- which.min(abs(hyperParams$alpha - AlphaCACHED$alpha))\n\n    cand.links <- which(!is.na(l.prior.mat[alphaIndex, aIndex, i,]))\n    log.prior <- l.prior.mat[alphaIndex, aIndex, i, cand.links]\n\n    ### compute the likelihood of data point i (and its connectors)\n    ### with all other tables (!!! do we need to use \"idx\"?)\n    cand.clusts <- unique(st$cluster[cand.links]) # different values for c.j\n\n    # new likelihood for clusters if you were to add link i\n    new.lhood <- daply(subset(st, cluster %in% cand.clusts), .(cluster),\n                       function (df)\n                         lhood.fn(dat[unique(c(df$idx,st[conn.i,\"idx\"])),], hyperParams$s))\n\n    if (length(new.lhood)==1) names(new.lhood) <- cand.clusts\n\n    ### set up the old likelihoods\n    old.lhood <- lhood[char(cand.clusts)] # p(k)\n    sum.old.lhood <- sum(old.lhood)\n\n    ### compute the conditional distribution\n    log.prob <-\n      log.prior +\n      laply(cand.links,\n            .fun=function (j) {\n              # This is just reusing the same likelihood\n              sum.old.lhood - old.lhood[char(st$cluster[j])] + new.lhood[char(st$cluster[j])] }) # for each i at a table, update the likelihood\n\n    prob <- exp(log.prob - log.sum(log.prob))\n    if (length(prob)==1)\n      st$customer[i] <- cand.links[1]\n    else\n      st$customer[i] <- sample(cand.links, 1, prob=prob)\n\n    ### update the score with the prior and update the clusters\n    iter.score <- iter.score + log.prior[which(cand.links == st$customer[i])]\n    st$cluster[conn.i] <- st$cluster[st$customer[i]]\n    clust.i.idx <- subset(st, cluster == st$cluster[i])$idx\n    lhood[char(st$cluster[i])] <- lhood.fn(dat[clust.i.idx,], hyperParams$s)\n  } # for i in 1:nCustomers\n\n  list(iter.score=iter.score, lhood=lhood, st=st)\n}\n\n",
    "created" : 1467236861899.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1456188667",
    "id" : "DC924442",
    "lastKnownWriteTime" : 1467252335,
    "path" : "~/Google Drive/Masters/Thesis/scripts/ddcrppaper/submission.code/ddclone/R/ddcrp-inference.R",
    "project_path" : "R/ddcrp-inference.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}